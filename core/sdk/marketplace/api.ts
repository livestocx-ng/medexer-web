/* tslint:disable */
/* eslint-disable */
/**
 * Marketplace Docs
 * Marketplace endpoints...
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddListItemDTO
 */
export interface AddListItemDTO {
    /**
     * ID of the item.
     * @type {string}
     * @memberof AddListItemDTO
     */
    'itemId': string;
    /**
     * Type of the list item.
     * @type {string}
     * @memberof AddListItemDTO
     */
    'itemType': AddListItemDTOItemTypeEnum;
    /**
     * Type of the list entity.
     * @type {string}
     * @memberof AddListItemDTO
     */
    'entityType': AddListItemDTOEntityTypeEnum;
}

export const AddListItemDTOItemTypeEnum = {
    Favorite: 'favorite',
    Like: 'like',
    Viewed: 'viewed',
    Wishlist: 'wishlist',
    SearchHistoryEntry: 'search-history-entry'
} as const;

export type AddListItemDTOItemTypeEnum = typeof AddListItemDTOItemTypeEnum[keyof typeof AddListItemDTOItemTypeEnum];
export const AddListItemDTOEntityTypeEnum = {
    Product: 'product',
    Vendor: 'vendor'
} as const;

export type AddListItemDTOEntityTypeEnum = typeof AddListItemDTOEntityTypeEnum[keyof typeof AddListItemDTOEntityTypeEnum];

/**
 * 
 * @export
 * @interface AddProductReviewDto
 */
export interface AddProductReviewDto {
    /**
     * Rating
     * @type {number}
     * @memberof AddProductReviewDto
     */
    'rating': number;
    /**
     * Review description
     * @type {string}
     * @memberof AddProductReviewDto
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface GroupedProductsResponse
 */
export interface GroupedProductsResponse {
    /**
     * 
     * @type {Array<ProductInfo>}
     * @memberof GroupedProductsResponse
     */
    'recommendedProducts': Array<ProductInfo>;
    /**
     * 
     * @type {Array<ProductInfo>}
     * @memberof GroupedProductsResponse
     */
    'popularProducts': Array<ProductInfo>;
    /**
     * 
     * @type {Array<ProductInfo>}
     * @memberof GroupedProductsResponse
     */
    'productsNearUser': Array<ProductInfo>;
    /**
     * 
     * @type {Array<ProductInfo>}
     * @memberof GroupedProductsResponse
     */
    'otherProducts': Array<ProductInfo>;
    /**
     * 
     * @type {number}
     * @memberof GroupedProductsResponse
     */
    'otherProductsTotalPages': number;
    /**
     * 
     * @type {boolean}
     * @memberof GroupedProductsResponse
     */
    'otherProductsHasNextPage': boolean;
}
/**
 * 
 * @export
 * @interface ListItemInfo
 */
export interface ListItemInfo {
    /**
     * List Item ID
     * @type {string}
     * @memberof ListItemInfo
     */
    'id': string;
    /**
     * List Item Type
     * @type {string}
     * @memberof ListItemInfo
     */
    'itemType': ListItemInfoItemTypeEnum;
    /**
     * ID of the item.
     * @type {string}
     * @memberof ListItemInfo
     */
    'itemId': string;
    /**
     * Type of the list entity.
     * @type {string}
     * @memberof ListItemInfo
     */
    'entityType': ListItemInfoEntityTypeEnum;
}

export const ListItemInfoItemTypeEnum = {
    Favorite: 'favorite',
    Like: 'like',
    Viewed: 'viewed',
    Wishlist: 'wishlist',
    SearchHistoryEntry: 'search-history-entry'
} as const;

export type ListItemInfoItemTypeEnum = typeof ListItemInfoItemTypeEnum[keyof typeof ListItemInfoItemTypeEnum];
export const ListItemInfoEntityTypeEnum = {
    Product: 'product',
    Vendor: 'vendor'
} as const;

export type ListItemInfoEntityTypeEnum = typeof ListItemInfoEntityTypeEnum[keyof typeof ListItemInfoEntityTypeEnum];

/**
 * 
 * @export
 * @interface MediaInfo
 */
export interface MediaInfo {
    /**
     * 
     * @type {string}
     * @memberof MediaInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MediaInfo
     */
    'mediaUrl': string;
    /**
     * The type of media
     * @type {string}
     * @memberof MediaInfo
     */
    'mediaType': MediaInfoMediaTypeEnum;
}

export const MediaInfoMediaTypeEnum = {
    Image: 'IMAGE',
    Video: 'VIDEO',
    Pdf: 'PDF'
} as const;

export type MediaInfoMediaTypeEnum = typeof MediaInfoMediaTypeEnum[keyof typeof MediaInfoMediaTypeEnum];

/**
 * 
 * @export
 * @interface ProductCategoryInfo
 */
export interface ProductCategoryInfo {
    /**
     * Name of the category.
     * @type {string}
     * @memberof ProductCategoryInfo
     */
    'name': string;
    /**
     * Value of the category.
     * @type {string}
     * @memberof ProductCategoryInfo
     */
    'value': ProductCategoryInfoValueEnum;
    /**
     * Image URL of the category.
     * @type {string}
     * @memberof ProductCategoryInfo
     */
    'imageUrl': string;
}

export const ProductCategoryInfoValueEnum = {
    Guineapig: 'GUINEAPIG',
    Cat: 'CAT',
    Dog: 'DOG',
    Goat: 'GOAT',
    Pig: 'PIG',
    Sheep: 'SHEEP',
    Fish: 'FISH',
    Rabbit: 'RABBIT',
    Snail: 'SNAIL',
    Cow: 'COW',
    Chicken: 'CHICKEN',
    Bird: 'BIRD',
    Turkey: 'TURKEY',
    Grasscutter: 'GRASSCUTTER'
} as const;

export type ProductCategoryInfoValueEnum = typeof ProductCategoryInfoValueEnum[keyof typeof ProductCategoryInfoValueEnum];

/**
 * 
 * @export
 * @interface ProductCharacteristicInfo
 */
export interface ProductCharacteristicInfo {
    /**
     * Name of the characteristic.
     * @type {string}
     * @memberof ProductCharacteristicInfo
     */
    'name': string;
    /**
     * Value of the characteristic.
     * @type {string}
     * @memberof ProductCharacteristicInfo
     */
    'value': string;
    /**
     * Type of the characteristic.
     * @type {string}
     * @memberof ProductCharacteristicInfo
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ProductDetails
 */
export interface ProductDetails {
    /**
     * 
     * @type {string}
     * @memberof ProductDetails
     */
    'averageRating': string;
    /**
     * 
     * @type {Array<ProductRatingInfo>}
     * @memberof ProductDetails
     */
    'ratings': Array<ProductRatingInfo>;
    /**
     * 
     * @type {Array<ProductReviewInfo>}
     * @memberof ProductDetails
     */
    'reviews': Array<ProductReviewInfo>;
    /**
     * 
     * @type {Array<ProductInfo>}
     * @memberof ProductDetails
     */
    'relatedProducts': Array<ProductInfo>;
    /**
     * 
     * @type {Array<ProductInfo>}
     * @memberof ProductDetails
     */
    'moreProducts': Array<ProductInfo>;
}
/**
 * 
 * @export
 * @interface ProductInfo
 */
export interface ProductInfo {
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'productId': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'price': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'discountPrice': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'category': ProductInfoCategoryEnum;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'description': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductInfo
     */
    'isNegotiable': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'impressionCount': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductInfo
     */
    'inStock': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'totalReviews': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'viewCount': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'likeCount': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductInfo
     */
    'isPromotion': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'coverPhoto': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'videoUrl'?: string;
    /**
     * 
     * @type {Array<MediaInfo>}
     * @memberof ProductInfo
     */
    'media': Array<MediaInfo>;
    /**
     * 
     * @type {ProductInfoVendor}
     * @memberof ProductInfo
     */
    'vendor': ProductInfoVendor;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfo
     */
    'createdAt': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductInfo
     */
    'isFlagged': boolean;
}

export const ProductInfoCategoryEnum = {
    Guineapig: 'GUINEAPIG',
    Cat: 'CAT',
    Dog: 'DOG',
    Goat: 'GOAT',
    Pig: 'PIG',
    Sheep: 'SHEEP',
    Fish: 'FISH',
    Rabbit: 'RABBIT',
    Snail: 'SNAIL',
    Cow: 'COW',
    Chicken: 'CHICKEN',
    Bird: 'BIRD',
    Turkey: 'TURKEY',
    Grasscutter: 'GRASSCUTTER'
} as const;

export type ProductInfoCategoryEnum = typeof ProductInfoCategoryEnum[keyof typeof ProductInfoCategoryEnum];

/**
 * 
 * @export
 * @interface ProductInfoVendor
 */
export interface ProductInfoVendor {
    /**
     * 
     * @type {string}
     * @memberof ProductInfoVendor
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfoVendor
     */
    'vendorId': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfoVendor
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfoVendor
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfoVendor
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfoVendor
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfoVendor
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfoVendor
     */
    'formattedAddress': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfoVendor
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfoVendor
     */
    'avatar': string;
    /**
     * 
     * @type {string}
     * @memberof ProductInfoVendor
     */
    'phoneNumber': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductInfoVendor
     */
    'isUpdated': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProductInfoVendor
     */
    'isProductUploadSubscriptionActive': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductInfoVendor
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface ProductRatingInfo
 */
export interface ProductRatingInfo {
    /**
     * 
     * @type {number}
     * @memberof ProductRatingInfo
     */
    'rating': number;
    /**
     * 
     * @type {number}
     * @memberof ProductRatingInfo
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface ProductReviewInfo
 */
export interface ProductReviewInfo {
    /**
     * 
     * @type {string}
     * @memberof ProductReviewInfo
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof ProductReviewInfo
     */
    'rating': string;
    /**
     * 
     * @type {string}
     * @memberof ProductReviewInfo
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof ProductReviewInfo
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof ProductReviewInfo
     */
    'avatar': string;
    /**
     * 
     * @type {string}
     * @memberof ProductReviewInfo
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ProductsResponse
 */
export interface ProductsResponse {
    /**
     * 
     * @type {Array<ProductInfo>}
     * @memberof ProductsResponse
     */
    'products': Array<ProductInfo>;
    /**
     * 
     * @type {number}
     * @memberof ProductsResponse
     */
    'totalPages': number;
    /**
     * 
     * @type {boolean}
     * @memberof ProductsResponse
     */
    'hasNextPage': boolean;
}
/**
 * 
 * @export
 * @interface SearchHintInfo
 */
export interface SearchHintInfo {
    /**
     * Name of the animal.
     * @type {string}
     * @memberof SearchHintInfo
     */
    'name': string;
    /**
     * City of the vendor.
     * @type {string}
     * @memberof SearchHintInfo
     */
    'city': string;
    /**
     * State of the vendor.
     * @type {string}
     * @memberof SearchHintInfo
     */
    'state': string;
    /**
     * City, State of the vendor.
     * @type {string}
     * @memberof SearchHintInfo
     */
    'formattedLocation': string;
}
/**
 * 
 * @export
 * @interface StoreInfo
 */
export interface StoreInfo {
    /**
     * 
     * @type {string}
     * @memberof StoreInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof StoreInfo
     */
    'vendorId': string;
    /**
     * 
     * @type {string}
     * @memberof StoreInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof StoreInfo
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof StoreInfo
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof StoreInfo
     */
    'city': string;
    /**
     * 
     * @type {string}
     * @memberof StoreInfo
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof StoreInfo
     */
    'formattedAddress': string;
    /**
     * 
     * @type {string}
     * @memberof StoreInfo
     */
    'avatar': string;
    /**
     * 
     * @type {string}
     * @memberof StoreInfo
     */
    'phoneNumber': string;
    /**
     * 
     * @type {boolean}
     * @memberof StoreInfo
     */
    'isUpdated': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StoreInfo
     */
    'isAccountDisabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof StoreInfo
     */
    'slug': string;
    /**
     * 
     * @type {string}
     * @memberof StoreInfo
     */
    'createdAt': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchHomeFeed: async (page: number, pageSize: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('marketplaceControllerFetchHomeFeed', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('marketplaceControllerFetchHomeFeed', 'pageSize', pageSize)
            const localVarPath = `/v1/marketplace/home-feed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerFetchHomeFeed(page: number, pageSize: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerFetchHomeFeed(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.marketplaceControllerFetchHomeFeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchHomeFeed(page: number, pageSize: number, options?: RawAxiosRequestConfig): AxiosPromise<ProductsResponse> {
            return localVarFp.marketplaceControllerFetchHomeFeed(page, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {number} page Page
     * @param {number} pageSize Page Size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public marketplaceControllerFetchHomeFeed(page: number, pageSize: number, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).marketplaceControllerFetchHomeFeed(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MarketplaceApi - axios parameter creator
 * @export
 */
export const MarketplaceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] Page
         * @param {number} [pageSize] Page Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchFeedGrouped: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/feed-grouped`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchPopularProducts: async (page: number, pageSize: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('marketplaceControllerFetchPopularProducts', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('marketplaceControllerFetchPopularProducts', 'pageSize', pageSize)
            const localVarPath = `/v1/marketplace/popular-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchProductsNearUser: async (page: number, pageSize: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('marketplaceControllerFetchProductsNearUser', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('marketplaceControllerFetchProductsNearUser', 'pageSize', pageSize)
            const localVarPath = `/v1/marketplace/products-near-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchRecommendedProducts: async (page: number, pageSize: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('marketplaceControllerFetchRecommendedProducts', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('marketplaceControllerFetchRecommendedProducts', 'pageSize', pageSize)
            const localVarPath = `/v1/marketplace/recommended-products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {string} [query] Search query
         * @param {string} [state] State
         * @param {string} [city] City
         * @param {string} [category] Category
         * @param {boolean} [inStock] In Stock
         * @param {boolean} [isNegotiable] Is Negotiable
         * @param {number} [latitude] Latitude
         * @param {number} [longitude] Longitude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchSearchFeed: async (page: number, pageSize: number, query?: string, state?: string, city?: string, category?: string, inStock?: boolean, isNegotiable?: boolean, latitude?: number, longitude?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('marketplaceControllerFetchSearchFeed', 'page', page)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('marketplaceControllerFetchSearchFeed', 'pageSize', pageSize)
            const localVarPath = `/v1/marketplace/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (city !== undefined) {
                localVarQueryParameter['city'] = city;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            if (inStock !== undefined) {
                localVarQueryParameter['inStock'] = inStock;
            }

            if (isNegotiable !== undefined) {
                localVarQueryParameter['isNegotiable'] = isNegotiable;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} query Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchSearchHints: async (query: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('marketplaceControllerFetchSearchHints', 'query', query)
            const localVarPath = `/v1/marketplace/search-hints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketplaceApi - functional programming interface
 * @export
 */
export const MarketplaceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketplaceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] Page
         * @param {number} [pageSize] Page Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerFetchFeedGrouped(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupedProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerFetchFeedGrouped(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.marketplaceControllerFetchFeedGrouped']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerFetchPopularProducts(page: number, pageSize: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerFetchPopularProducts(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.marketplaceControllerFetchPopularProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerFetchProductsNearUser(page: number, pageSize: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerFetchProductsNearUser(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.marketplaceControllerFetchProductsNearUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerFetchRecommendedProducts(page: number, pageSize: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerFetchRecommendedProducts(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.marketplaceControllerFetchRecommendedProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {string} [query] Search query
         * @param {string} [state] State
         * @param {string} [city] City
         * @param {string} [category] Category
         * @param {boolean} [inStock] In Stock
         * @param {boolean} [isNegotiable] Is Negotiable
         * @param {number} [latitude] Latitude
         * @param {number} [longitude] Longitude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerFetchSearchFeed(page: number, pageSize: number, query?: string, state?: string, city?: string, category?: string, inStock?: boolean, isNegotiable?: boolean, latitude?: number, longitude?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerFetchSearchFeed(page, pageSize, query, state, city, category, inStock, isNegotiable, latitude, longitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.marketplaceControllerFetchSearchFeed']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} query Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerFetchSearchHints(query: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SearchHintInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerFetchSearchHints(query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MarketplaceApi.marketplaceControllerFetchSearchHints']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MarketplaceApi - factory interface
 * @export
 */
export const MarketplaceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketplaceApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] Page
         * @param {number} [pageSize] Page Size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchFeedGrouped(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<GroupedProductsResponse> {
            return localVarFp.marketplaceControllerFetchFeedGrouped(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchPopularProducts(page: number, pageSize: number, options?: RawAxiosRequestConfig): AxiosPromise<ProductsResponse> {
            return localVarFp.marketplaceControllerFetchPopularProducts(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchProductsNearUser(page: number, pageSize: number, options?: RawAxiosRequestConfig): AxiosPromise<ProductsResponse> {
            return localVarFp.marketplaceControllerFetchProductsNearUser(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchRecommendedProducts(page: number, pageSize: number, options?: RawAxiosRequestConfig): AxiosPromise<ProductsResponse> {
            return localVarFp.marketplaceControllerFetchRecommendedProducts(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} page Page
         * @param {number} pageSize Page size
         * @param {string} [query] Search query
         * @param {string} [state] State
         * @param {string} [city] City
         * @param {string} [category] Category
         * @param {boolean} [inStock] In Stock
         * @param {boolean} [isNegotiable] Is Negotiable
         * @param {number} [latitude] Latitude
         * @param {number} [longitude] Longitude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchSearchFeed(page: number, pageSize: number, query?: string, state?: string, city?: string, category?: string, inStock?: boolean, isNegotiable?: boolean, latitude?: number, longitude?: number, options?: RawAxiosRequestConfig): AxiosPromise<ProductsResponse> {
            return localVarFp.marketplaceControllerFetchSearchFeed(page, pageSize, query, state, city, category, inStock, isNegotiable, latitude, longitude, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} query Query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchSearchHints(query: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SearchHintInfo>> {
            return localVarFp.marketplaceControllerFetchSearchHints(query, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketplaceApi - object-oriented interface
 * @export
 * @class MarketplaceApi
 * @extends {BaseAPI}
 */
export class MarketplaceApi extends BaseAPI {
    /**
     * 
     * @param {number} [page] Page
     * @param {number} [pageSize] Page Size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerFetchFeedGrouped(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerFetchFeedGrouped(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} page Page
     * @param {number} pageSize Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerFetchPopularProducts(page: number, pageSize: number, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerFetchPopularProducts(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} page Page
     * @param {number} pageSize Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerFetchProductsNearUser(page: number, pageSize: number, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerFetchProductsNearUser(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} page Page
     * @param {number} pageSize Page size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerFetchRecommendedProducts(page: number, pageSize: number, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerFetchRecommendedProducts(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} page Page
     * @param {number} pageSize Page size
     * @param {string} [query] Search query
     * @param {string} [state] State
     * @param {string} [city] City
     * @param {string} [category] Category
     * @param {boolean} [inStock] In Stock
     * @param {boolean} [isNegotiable] Is Negotiable
     * @param {number} [latitude] Latitude
     * @param {number} [longitude] Longitude
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerFetchSearchFeed(page: number, pageSize: number, query?: string, state?: string, city?: string, category?: string, inStock?: boolean, isNegotiable?: boolean, latitude?: number, longitude?: number, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerFetchSearchFeed(page, pageSize, query, state, city, category, inStock, isNegotiable, latitude, longitude, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} query Query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketplaceApi
     */
    public marketplaceControllerFetchSearchHints(query: string, options?: RawAxiosRequestConfig) {
        return MarketplaceApiFp(this.configuration).marketplaceControllerFetchSearchHints(query, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MiscellaneousApi - axios parameter creator
 * @export
 */
export const MiscellaneousApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchFormattedProductCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/product-categories/formatted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchProductCategories: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/product-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchProductCharacteristics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/product-characteristics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscellaneousApi - functional programming interface
 * @export
 */
export const MiscellaneousApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiscellaneousApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerFetchFormattedProductCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductCategoryInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerFetchFormattedProductCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscellaneousApi.marketplaceControllerFetchFormattedProductCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerFetchProductCategories(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerFetchProductCategories(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscellaneousApi.marketplaceControllerFetchProductCategories']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerFetchProductCharacteristics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductCharacteristicInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerFetchProductCharacteristics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MiscellaneousApi.marketplaceControllerFetchProductCharacteristics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MiscellaneousApi - factory interface
 * @export
 */
export const MiscellaneousApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiscellaneousApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchFormattedProductCategories(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductCategoryInfo>> {
            return localVarFp.marketplaceControllerFetchFormattedProductCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchProductCategories(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.marketplaceControllerFetchProductCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchProductCharacteristics(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductCharacteristicInfo>> {
            return localVarFp.marketplaceControllerFetchProductCharacteristics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiscellaneousApi - object-oriented interface
 * @export
 * @class MiscellaneousApi
 * @extends {BaseAPI}
 */
export class MiscellaneousApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public marketplaceControllerFetchFormattedProductCategories(options?: RawAxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).marketplaceControllerFetchFormattedProductCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public marketplaceControllerFetchProductCategories(options?: RawAxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).marketplaceControllerFetchProductCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscellaneousApi
     */
    public marketplaceControllerFetchProductCharacteristics(options?: RawAxiosRequestConfig) {
        return MiscellaneousApiFp(this.configuration).marketplaceControllerFetchProductCharacteristics(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerAddProductImpression: async (productId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('marketplaceControllerAddProductImpression', 'productId', productId)
            const localVarPath = `/v1/marketplace/product/add-impression`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {AddProductReviewDto} addProductReviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerAddReview: async (productId: number, addProductReviewDto: AddProductReviewDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('marketplaceControllerAddReview', 'productId', productId)
            // verify required parameter 'addProductReviewDto' is not null or undefined
            assertParamExists('marketplaceControllerAddReview', 'addProductReviewDto', addProductReviewDto)
            const localVarPath = `/v1/marketplace/product/add-review`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addProductReviewDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} productId Formatted Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchProductDescription: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('marketplaceControllerFetchProductDescription', 'productId', productId)
            const localVarPath = `/v1/marketplace/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} productId Formatted Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchProductInfo: async (productId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('marketplaceControllerFetchProductInfo', 'productId', productId)
            const localVarPath = `/v1/marketplace/product/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerRegisterCallSeller: async (productId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('marketplaceControllerRegisterCallSeller', 'productId', productId)
            const localVarPath = `/v1/marketplace/product/register-call-seller`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerRegisterContactSeller: async (productId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('marketplaceControllerRegisterContactSeller', 'productId', productId)
            const localVarPath = `/v1/marketplace/product/register-contact-seller`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerRegisterViewProduct: async (productId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productId' is not null or undefined
            assertParamExists('marketplaceControllerRegisterViewProduct', 'productId', productId)
            const localVarPath = `/v1/marketplace/product/register-view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (productId !== undefined) {
                localVarQueryParameter['productId'] = productId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerAddProductImpression(productId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerAddProductImpression(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.marketplaceControllerAddProductImpression']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {AddProductReviewDto} addProductReviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerAddReview(productId: number, addProductReviewDto: AddProductReviewDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerAddReview(productId, addProductReviewDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.marketplaceControllerAddReview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} productId Formatted Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerFetchProductDescription(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerFetchProductDescription(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.marketplaceControllerFetchProductDescription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} productId Formatted Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerFetchProductInfo(productId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerFetchProductInfo(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.marketplaceControllerFetchProductInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerRegisterCallSeller(productId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerRegisterCallSeller(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.marketplaceControllerRegisterCallSeller']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerRegisterContactSeller(productId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerRegisterContactSeller(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.marketplaceControllerRegisterContactSeller']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketplaceControllerRegisterViewProduct(productId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.marketplaceControllerRegisterViewProduct(productId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductApi.marketplaceControllerRegisterViewProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerAddProductImpression(productId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.marketplaceControllerAddProductImpression(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {AddProductReviewDto} addProductReviewDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerAddReview(productId: number, addProductReviewDto: AddProductReviewDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.marketplaceControllerAddReview(productId, addProductReviewDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} productId Formatted Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchProductDescription(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductInfo> {
            return localVarFp.marketplaceControllerFetchProductDescription(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} productId Formatted Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerFetchProductInfo(productId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductDetails> {
            return localVarFp.marketplaceControllerFetchProductInfo(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerRegisterCallSeller(productId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.marketplaceControllerRegisterCallSeller(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerRegisterContactSeller(productId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.marketplaceControllerRegisterContactSeller(productId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} productId Product Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketplaceControllerRegisterViewProduct(productId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.marketplaceControllerRegisterViewProduct(productId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @param {number} productId Product Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public marketplaceControllerAddProductImpression(productId: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).marketplaceControllerAddProductImpression(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} productId Product Id
     * @param {AddProductReviewDto} addProductReviewDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public marketplaceControllerAddReview(productId: number, addProductReviewDto: AddProductReviewDto, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).marketplaceControllerAddReview(productId, addProductReviewDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} productId Formatted Product Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public marketplaceControllerFetchProductDescription(productId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).marketplaceControllerFetchProductDescription(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} productId Formatted Product Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public marketplaceControllerFetchProductInfo(productId: string, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).marketplaceControllerFetchProductInfo(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} productId Product Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public marketplaceControllerRegisterCallSeller(productId: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).marketplaceControllerRegisterCallSeller(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} productId Product Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public marketplaceControllerRegisterContactSeller(productId: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).marketplaceControllerRegisterContactSeller(productId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} productId Product Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public marketplaceControllerRegisterViewProduct(productId: number, options?: RawAxiosRequestConfig) {
        return ProductApiFp(this.configuration).marketplaceControllerRegisterViewProduct(productId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} page 
         * @param {number} storeId 
         * @param {number} pageSize 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFetchStoreProducts: async (page: number, storeId: number, pageSize: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('storeControllerFetchStoreProducts', 'page', page)
            // verify required parameter 'storeId' is not null or undefined
            assertParamExists('storeControllerFetchStoreProducts', 'storeId', storeId)
            // verify required parameter 'pageSize' is not null or undefined
            assertParamExists('storeControllerFetchStoreProducts', 'pageSize', pageSize)
            const localVarPath = `/v1/marketplace/store/profile/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (storeId !== undefined) {
                localVarQueryParameter['storeId'] = storeId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFetchStoreProfile: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('storeControllerFetchStoreProfile', 'slug', slug)
            const localVarPath = `/v1/marketplace/store/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} page 
         * @param {number} storeId 
         * @param {number} pageSize 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeControllerFetchStoreProducts(page: number, storeId: number, pageSize: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeControllerFetchStoreProducts(page, storeId, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.storeControllerFetchStoreProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeControllerFetchStoreProfile(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeControllerFetchStoreProfile(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreApi.storeControllerFetchStoreProfile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreApiFp(configuration)
    return {
        /**
         * 
         * @param {number} page 
         * @param {number} storeId 
         * @param {number} pageSize 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFetchStoreProducts(page: number, storeId: number, pageSize: number, options?: RawAxiosRequestConfig): AxiosPromise<ProductsResponse> {
            return localVarFp.storeControllerFetchStoreProducts(page, storeId, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeControllerFetchStoreProfile(slug: string, options?: RawAxiosRequestConfig): AxiosPromise<StoreInfo> {
            return localVarFp.storeControllerFetchStoreProfile(slug, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * 
     * @param {number} page 
     * @param {number} storeId 
     * @param {number} pageSize 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeControllerFetchStoreProducts(page: number, storeId: number, pageSize: number, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeControllerFetchStoreProducts(page, storeId, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public storeControllerFetchStoreProfile(slug: string, options?: RawAxiosRequestConfig) {
        return StoreApiFp(this.configuration).storeControllerFetchStoreProfile(slug, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserListApi - axios parameter creator
 * @export
 */
export const UserListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add an item to a user\'s list
         * @param {AddListItemDTO} addListItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerAddItemToList: async (addListItemDTO: AddListItemDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addListItemDTO' is not null or undefined
            assertParamExists('listItemControllerAddItemToList', 'addListItemDTO', addListItemDTO)
            const localVarPath = `/v1/marketplace/list-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addListItemDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all list items for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerGetUserList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/marketplace/list-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an item from a user\'s list
         * @param {number} itemId ID of the list item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerRemoveItemFromList: async (itemId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('listItemControllerRemoveItemFromList', 'itemId', itemId)
            const localVarPath = `/v1/marketplace/list-items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserListApi - functional programming interface
 * @export
 */
export const UserListApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserListApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add an item to a user\'s list
         * @param {AddListItemDTO} addListItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemControllerAddItemToList(addListItemDTO: AddListItemDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListItemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemControllerAddItemToList(addListItemDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserListApi.listItemControllerAddItemToList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all list items for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemControllerGetUserList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListItemInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemControllerGetUserList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserListApi.listItemControllerGetUserList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove an item from a user\'s list
         * @param {number} itemId ID of the list item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemControllerRemoveItemFromList(itemId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemControllerRemoveItemFromList(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserListApi.listItemControllerRemoveItemFromList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserListApi - factory interface
 * @export
 */
export const UserListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserListApiFp(configuration)
    return {
        /**
         * 
         * @summary Add an item to a user\'s list
         * @param {AddListItemDTO} addListItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerAddItemToList(addListItemDTO: AddListItemDTO, options?: RawAxiosRequestConfig): AxiosPromise<ListItemInfo> {
            return localVarFp.listItemControllerAddItemToList(addListItemDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all list items for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerGetUserList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ListItemInfo>> {
            return localVarFp.listItemControllerGetUserList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an item from a user\'s list
         * @param {number} itemId ID of the list item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerRemoveItemFromList(itemId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listItemControllerRemoveItemFromList(itemId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserListApi - object-oriented interface
 * @export
 * @class UserListApi
 * @extends {BaseAPI}
 */
export class UserListApi extends BaseAPI {
    /**
     * 
     * @summary Add an item to a user\'s list
     * @param {AddListItemDTO} addListItemDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserListApi
     */
    public listItemControllerAddItemToList(addListItemDTO: AddListItemDTO, options?: RawAxiosRequestConfig) {
        return UserListApiFp(this.configuration).listItemControllerAddItemToList(addListItemDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all list items for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserListApi
     */
    public listItemControllerGetUserList(options?: RawAxiosRequestConfig) {
        return UserListApiFp(this.configuration).listItemControllerGetUserList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an item from a user\'s list
     * @param {number} itemId ID of the list item to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserListApi
     */
    public listItemControllerRemoveItemFromList(itemId: number, options?: RawAxiosRequestConfig) {
        return UserListApiFp(this.configuration).listItemControllerRemoveItemFromList(itemId, options).then((request) => request(this.axios, this.basePath));
    }
}



